---
title: mysql学习笔记（二）
date: 2017-02-11 23:55:11
tags:
    - mysql
categories: mysql
---
## 选择优化的数据类型
MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。
下面有几个数据类型选择的原则
+ 更小的通常更好：尽量选择可以正确存储数据的最小数据类型。更小的暂用空间，消耗资源更少。
+ 简单就好：简单的数据类型通常需要更少的cpu周期。例如可以使用整数存储的就不要使用字符串了。
+ 尽量避免NULL：大部分设计的时候通常会跟列添加默认值null。列值为null的，在mysql建立索引，索引统计，值比较更加复杂。

## 整数类型
整数类型：tinyint、smallinit、mediumint、int、bigint,
分别使用8,16,24,32,64位的存储空间。他们存储的值范围是$-2^(n-2)$
到$2^(n-1)-1$。可以设置unsigned设置存储为不存储负数，则整数存储范围加倍。
但是两者的性能是一致的。

> tips：mysql可以为整数类型指定宽度。例：int(11),int(1)。对大多数应用是无用的，两者的效果一样。只是
对一部分交互工具展示的字符个数有作用。

## 实数类型
不精确类型：float,double
精确类型：decimal

## 字符串类型
1. varchar： 用于存储可边长字符串。比定长类型节省空间，该类型只占用必要的空间。
varchar需要一个或两个额外的字节记录字符串的长度。如果列长度小于等于255则只需要一个字节，
或则需要两个字节。使用场景：最大长度比平均长度长很多，变化较少。
2. char：char类型是定长的，mysql根据定义长度分配足够的空间。char类型适合存储长度
接近同一个值的字段类型。
> mysql储存char类型的时候会删除字符串末尾的空格。

3. blob和text：为了存储很大的的数据而设计的字符串类型。
包括：tinytext,smalltext,text,mediumtext,longtext和tinyblog,smallblob,
blob,longblob。其中smalltext跟text一样，blob和smallblob一样。

4. 使用枚举类型代替字符串

某列的可取值是有限的情况下，可以使用枚举类型。

```
mysql> create table enum_test(
    -> e enum('fish', 'apple', 'dog') not null
    ->);
```
每行存储的实际上是整数，排序的话也是按整数排序。

## 日期和时间
datetime：这个类型保存的范围是1001-9999，精度为秒。
timestamp：保存1970-2038之间的时间值。timestamp的值受时区的影响。
timestamp不赋值时，系统会赋值为当前值。一般使用timestamp，比datetime效率高。

## 位数据类型

MySQL有少数几种存储类型使用位存储数据，这些不管地秤的存储格式和处理方式如何，从技术上来讲都是字符串类型。

+ bit:可以使用bit类型存储一个或多个true/false值。bit(1)定义一个包含单个位的字段，以此类推。bit最大包含64个位。
Mysql把bit当做字符串类型，但检索到bit(1)结果是一个包含二进制0或1的字符串，而不是ASCII码'0'或'1'。
然而在数字的上下文中，结果将是位字符串转换成数字。
例如：
```
mysql> create table bittest(abit(8));
mysql> insert into bittest values(b'0111001');
mysql> select a, a+0 from bittest;
```

result:
| a | a+0 |
| - | - |
| 9 | 57 |

这样很容易让人费解或出错，所以尽量不要使用该类型。可以用char(0)或tinyint代替。

+ set:如果保存很多true/false值，可以考虑合并这些列到一个set数据类型，它在mysql内部是以一系列打包的位的集合表示的。
这样有效利用了空间，并且mysql里有find_in_set()和field()这样的函数。方便在查询中使用。缺点是在添加一个新的值时，alter table代价比较高。

> tips:在需要使用该类型数据时，可以使用int型来代替，例如tinyint表示八种true/false。相关逻辑实现可在自己代码里实现。

## 标识符选择
标识符选择注意项：
1. 标识符和其在其他表里作为外键的定义要完全一致。例如：int型的unsigned也要一致。因为这些字段有可能
会在查询中做比较，类型不一致可能会造成性能问题或难以发现的错误。
2. 在可以满足值的范围的条件下并且预留未来增长的空间时，应该选择最小的数据类型。
3. 整数类型通常是标识符的最佳选择，因为他们很快并可以用auto_increment。
4. 尽量避免使用string类型，因为他们消耗空间且比整数类型慢。

> tips: 字符串的随机性比较大，插入值会写到索引的不同位置，insert会很慢，会导致页分裂，
磁盘随机访问，以及对于聚簇索引产生聚簇索引碎片。同样select也会很慢，因为逻辑上相同的行
可能分布在不同磁盘空间。

## 特殊数据类型
某些类型的数据不直接和内置类型一致。低于秒级精度的时间戳（使用bitint存储时间戳，或float类型小数部分存储秒以后的数值）就是一个例子。

IPv4一本会本人存储为varchar(15)。但是实际上ip是32位无符号的整数。mysql的存储方式是存储为int型。
mysql并提供inet_aton() 和 inet_ntoa()函数在两者之间转换。

## MySQL schema设计中的陷阱

+ 太多的列：MySQL的存储引擎API工作时需要在服务器和存储引擎之间通过行缓存格式拷贝数据，然后在服务器层将缓存解码成各个列。
从行缓冲将编码过的列转换成行数据结构代价非常高。MyISAM的定长行结构实际上和服务器层的行结构正好匹配不需要转换。然而MyISAM的边长行和InnoDB的行结构总是需要转换。

+ 太多的关联：MySQL限制了每个关联操作最多只能有61个表。如果希望查询执行的快速并且并发性好，
单个查询最好控制在12个关联表以内。

+ 全能的枚举：防止过分使用枚举，例如：
```
mysql> create table test(
mysq > country enu('','0','1','2'……'31'));
```
这样就太过复杂了。

## 缓存表和汇总表
有时候提升mysql的性能的办法是在一张表里保存衍生的冗余数据。有时候也需要创建独立的缓存表或汇总表。
1. 缓存表：有时候可能需要各种不同的索引组合去查询数据，数据来源也可能不是单一表，这个时候就需要创建包含仅需要的列的一个独立表。
混存表可以使用不同的存储引擎（例如：利用MyISAM来支持全文索引）,或则使用专门的检索服务例如solr,lucene等。

2. 汇总表：汇总表一般用来保存group得到的结果（例如：当前所有的聊天消息数量等）。这类可以每小时统计以下前一个小时数据表里（保存所有数据的列表）的数量，并把每小时的数量保存在一个单独表即汇总表，这样当查询当前一共有多少消息时，只需要根据汇总表里查出当前小时以前的所有数量，再查当前小时在数据表里的数量相加即可。

> 统计某商品收藏人数实现：该数据的实时性要求并不高，可以根据商品id在redis里记录收藏数量及收藏id，定时去查询收藏表，并把大于该收藏id的收藏条数加到redis里维护的值上，修改当前收藏id即可。

### 物化视图表
许多数据库实现了物化视图表，该表是计算当前磁盘上所有信息得到的表，并根据各种策略（日志记录等）去更新。物化视图跟缓存表和汇总表相比，物化视图提取表的原始修改，不再去查表统计，所以性能更好。
mysql虽然没有实现物化视图，但是可以通过开源工具flexviews等来实现。

### 计数器表
前面统计商品的数量是使用redis实现的，并不实时，可以使用如下方式增加实时和并发。

在表里存储10行，slot=1、slot=2、……slot=10。每次更新的时候随机更新某一行。
```
mysql> update num_table set count=count+1 where slot=rand()*10;
```

统计总数量：
```
mysql> select sum(count) from num_table;
```

## 加快alter table的速度
mysql的alter table操作对于大表而言是个大问题。mysql大部分修改表结构的方式是：创建相同结构的新表，把老表数据倒入新表，删除老表。该过程对内存，索引大小的依赖很大。该过程时间会很长，甚至数天时间，而且期间会锁表，但是服务中断，所以要谨慎操作。

### 只修改.frm文件
**该方式非官方支持，谨慎使用**
可使用的修改类型：
+ 移除一个列的的auto_increment属性
+ 增加、移除、更改 enum和set常量
一共四步：
1. 创建一个相同结构的空表，并对空表进行想用的修改（例如删除id的自增：alter table test_table modify column id int)
2. 执行flush tables with read lock.这将关闭所有正在使用表，并禁止任何表被打开。
3. 交换两个表的.frm文件
4. 执行 unlock tables解除步骤2的锁定


